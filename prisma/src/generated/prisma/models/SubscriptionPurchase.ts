
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `SubscriptionPurchase` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums.ts"
import type * as Prisma from "../internal/prismaNamespace.ts"

/**
 * Model SubscriptionPurchase
 * 
 */
export type SubscriptionPurchaseModel = runtime.Types.Result.DefaultSelection<Prisma.$SubscriptionPurchasePayload>

export type AggregateSubscriptionPurchase = {
  _count: SubscriptionPurchaseCountAggregateOutputType | null
  _avg: SubscriptionPurchaseAvgAggregateOutputType | null
  _sum: SubscriptionPurchaseSumAggregateOutputType | null
  _min: SubscriptionPurchaseMinAggregateOutputType | null
  _max: SubscriptionPurchaseMaxAggregateOutputType | null
}

export type SubscriptionPurchaseAvgAggregateOutputType = {
  price_paid: runtime.Decimal | null
}

export type SubscriptionPurchaseSumAggregateOutputType = {
  price_paid: runtime.Decimal | null
}

export type SubscriptionPurchaseMinAggregateOutputType = {
  id: string | null
  user_id: string | null
  subscription_plan_id: string | null
  price_paid: runtime.Decimal | null
  currency: $Enums.CurrencyEnum | null
  purchased_at: Date | null
  expires_at: Date | null
}

export type SubscriptionPurchaseMaxAggregateOutputType = {
  id: string | null
  user_id: string | null
  subscription_plan_id: string | null
  price_paid: runtime.Decimal | null
  currency: $Enums.CurrencyEnum | null
  purchased_at: Date | null
  expires_at: Date | null
}

export type SubscriptionPurchaseCountAggregateOutputType = {
  id: number
  user_id: number
  subscription_plan_id: number
  price_paid: number
  currency: number
  purchased_at: number
  expires_at: number
  _all: number
}


export type SubscriptionPurchaseAvgAggregateInputType = {
  price_paid?: true
}

export type SubscriptionPurchaseSumAggregateInputType = {
  price_paid?: true
}

export type SubscriptionPurchaseMinAggregateInputType = {
  id?: true
  user_id?: true
  subscription_plan_id?: true
  price_paid?: true
  currency?: true
  purchased_at?: true
  expires_at?: true
}

export type SubscriptionPurchaseMaxAggregateInputType = {
  id?: true
  user_id?: true
  subscription_plan_id?: true
  price_paid?: true
  currency?: true
  purchased_at?: true
  expires_at?: true
}

export type SubscriptionPurchaseCountAggregateInputType = {
  id?: true
  user_id?: true
  subscription_plan_id?: true
  price_paid?: true
  currency?: true
  purchased_at?: true
  expires_at?: true
  _all?: true
}

export type SubscriptionPurchaseAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which SubscriptionPurchase to aggregate.
   */
  where?: Prisma.SubscriptionPurchaseWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of SubscriptionPurchases to fetch.
   */
  orderBy?: Prisma.SubscriptionPurchaseOrderByWithRelationInput | Prisma.SubscriptionPurchaseOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.SubscriptionPurchaseWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` SubscriptionPurchases from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` SubscriptionPurchases.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned SubscriptionPurchases
  **/
  _count?: true | SubscriptionPurchaseCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: SubscriptionPurchaseAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: SubscriptionPurchaseSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: SubscriptionPurchaseMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: SubscriptionPurchaseMaxAggregateInputType
}

export type GetSubscriptionPurchaseAggregateType<T extends SubscriptionPurchaseAggregateArgs> = {
      [P in keyof T & keyof AggregateSubscriptionPurchase]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateSubscriptionPurchase[P]>
    : Prisma.GetScalarType<T[P], AggregateSubscriptionPurchase[P]>
}




export type SubscriptionPurchaseGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.SubscriptionPurchaseWhereInput
  orderBy?: Prisma.SubscriptionPurchaseOrderByWithAggregationInput | Prisma.SubscriptionPurchaseOrderByWithAggregationInput[]
  by: Prisma.SubscriptionPurchaseScalarFieldEnum[] | Prisma.SubscriptionPurchaseScalarFieldEnum
  having?: Prisma.SubscriptionPurchaseScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: SubscriptionPurchaseCountAggregateInputType | true
  _avg?: SubscriptionPurchaseAvgAggregateInputType
  _sum?: SubscriptionPurchaseSumAggregateInputType
  _min?: SubscriptionPurchaseMinAggregateInputType
  _max?: SubscriptionPurchaseMaxAggregateInputType
}

export type SubscriptionPurchaseGroupByOutputType = {
  id: string
  user_id: string
  subscription_plan_id: string
  price_paid: runtime.Decimal
  currency: $Enums.CurrencyEnum
  purchased_at: Date
  expires_at: Date
  _count: SubscriptionPurchaseCountAggregateOutputType | null
  _avg: SubscriptionPurchaseAvgAggregateOutputType | null
  _sum: SubscriptionPurchaseSumAggregateOutputType | null
  _min: SubscriptionPurchaseMinAggregateOutputType | null
  _max: SubscriptionPurchaseMaxAggregateOutputType | null
}

type GetSubscriptionPurchaseGroupByPayload<T extends SubscriptionPurchaseGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<SubscriptionPurchaseGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof SubscriptionPurchaseGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], SubscriptionPurchaseGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], SubscriptionPurchaseGroupByOutputType[P]>
      }
    >
  >



export type SubscriptionPurchaseWhereInput = {
  AND?: Prisma.SubscriptionPurchaseWhereInput | Prisma.SubscriptionPurchaseWhereInput[]
  OR?: Prisma.SubscriptionPurchaseWhereInput[]
  NOT?: Prisma.SubscriptionPurchaseWhereInput | Prisma.SubscriptionPurchaseWhereInput[]
  id?: Prisma.StringFilter<"SubscriptionPurchase"> | string
  user_id?: Prisma.StringFilter<"SubscriptionPurchase"> | string
  subscription_plan_id?: Prisma.StringFilter<"SubscriptionPurchase"> | string
  price_paid?: Prisma.DecimalFilter<"SubscriptionPurchase"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  currency?: Prisma.EnumCurrencyEnumFilter<"SubscriptionPurchase"> | $Enums.CurrencyEnum
  purchased_at?: Prisma.DateTimeFilter<"SubscriptionPurchase"> | Date | string
  expires_at?: Prisma.DateTimeFilter<"SubscriptionPurchase"> | Date | string
  SubscriptionPlan?: Prisma.XOR<Prisma.SubscriptionPlanScalarRelationFilter, Prisma.SubscriptionPlanWhereInput>
  User?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
}

export type SubscriptionPurchaseOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  user_id?: Prisma.SortOrder
  subscription_plan_id?: Prisma.SortOrder
  price_paid?: Prisma.SortOrder
  currency?: Prisma.SortOrder
  purchased_at?: Prisma.SortOrder
  expires_at?: Prisma.SortOrder
  SubscriptionPlan?: Prisma.SubscriptionPlanOrderByWithRelationInput
  User?: Prisma.UserOrderByWithRelationInput
  _relevance?: Prisma.SubscriptionPurchaseOrderByRelevanceInput
}

export type SubscriptionPurchaseWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.SubscriptionPurchaseWhereInput | Prisma.SubscriptionPurchaseWhereInput[]
  OR?: Prisma.SubscriptionPurchaseWhereInput[]
  NOT?: Prisma.SubscriptionPurchaseWhereInput | Prisma.SubscriptionPurchaseWhereInput[]
  user_id?: Prisma.StringFilter<"SubscriptionPurchase"> | string
  subscription_plan_id?: Prisma.StringFilter<"SubscriptionPurchase"> | string
  price_paid?: Prisma.DecimalFilter<"SubscriptionPurchase"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  currency?: Prisma.EnumCurrencyEnumFilter<"SubscriptionPurchase"> | $Enums.CurrencyEnum
  purchased_at?: Prisma.DateTimeFilter<"SubscriptionPurchase"> | Date | string
  expires_at?: Prisma.DateTimeFilter<"SubscriptionPurchase"> | Date | string
  SubscriptionPlan?: Prisma.XOR<Prisma.SubscriptionPlanScalarRelationFilter, Prisma.SubscriptionPlanWhereInput>
  User?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
}, "id">

export type SubscriptionPurchaseOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  user_id?: Prisma.SortOrder
  subscription_plan_id?: Prisma.SortOrder
  price_paid?: Prisma.SortOrder
  currency?: Prisma.SortOrder
  purchased_at?: Prisma.SortOrder
  expires_at?: Prisma.SortOrder
  _count?: Prisma.SubscriptionPurchaseCountOrderByAggregateInput
  _avg?: Prisma.SubscriptionPurchaseAvgOrderByAggregateInput
  _max?: Prisma.SubscriptionPurchaseMaxOrderByAggregateInput
  _min?: Prisma.SubscriptionPurchaseMinOrderByAggregateInput
  _sum?: Prisma.SubscriptionPurchaseSumOrderByAggregateInput
}

export type SubscriptionPurchaseScalarWhereWithAggregatesInput = {
  AND?: Prisma.SubscriptionPurchaseScalarWhereWithAggregatesInput | Prisma.SubscriptionPurchaseScalarWhereWithAggregatesInput[]
  OR?: Prisma.SubscriptionPurchaseScalarWhereWithAggregatesInput[]
  NOT?: Prisma.SubscriptionPurchaseScalarWhereWithAggregatesInput | Prisma.SubscriptionPurchaseScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"SubscriptionPurchase"> | string
  user_id?: Prisma.StringWithAggregatesFilter<"SubscriptionPurchase"> | string
  subscription_plan_id?: Prisma.StringWithAggregatesFilter<"SubscriptionPurchase"> | string
  price_paid?: Prisma.DecimalWithAggregatesFilter<"SubscriptionPurchase"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  currency?: Prisma.EnumCurrencyEnumWithAggregatesFilter<"SubscriptionPurchase"> | $Enums.CurrencyEnum
  purchased_at?: Prisma.DateTimeWithAggregatesFilter<"SubscriptionPurchase"> | Date | string
  expires_at?: Prisma.DateTimeWithAggregatesFilter<"SubscriptionPurchase"> | Date | string
}

export type SubscriptionPurchaseCreateInput = {
  id?: string
  price_paid: runtime.Decimal | runtime.DecimalJsLike | number | string
  currency: $Enums.CurrencyEnum
  purchased_at: Date | string
  expires_at: Date | string
  SubscriptionPlan: Prisma.SubscriptionPlanCreateNestedOneWithoutSubscriptionPurchaseInput
  User: Prisma.UserCreateNestedOneWithoutSubscriptionPurchaseInput
}

export type SubscriptionPurchaseUncheckedCreateInput = {
  id?: string
  user_id: string
  subscription_plan_id: string
  price_paid: runtime.Decimal | runtime.DecimalJsLike | number | string
  currency: $Enums.CurrencyEnum
  purchased_at: Date | string
  expires_at: Date | string
}

export type SubscriptionPurchaseUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  price_paid?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  currency?: Prisma.EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
  purchased_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expires_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  SubscriptionPlan?: Prisma.SubscriptionPlanUpdateOneRequiredWithoutSubscriptionPurchaseNestedInput
  User?: Prisma.UserUpdateOneRequiredWithoutSubscriptionPurchaseNestedInput
}

export type SubscriptionPurchaseUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  user_id?: Prisma.StringFieldUpdateOperationsInput | string
  subscription_plan_id?: Prisma.StringFieldUpdateOperationsInput | string
  price_paid?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  currency?: Prisma.EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
  purchased_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expires_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SubscriptionPurchaseCreateManyInput = {
  id?: string
  user_id: string
  subscription_plan_id: string
  price_paid: runtime.Decimal | runtime.DecimalJsLike | number | string
  currency: $Enums.CurrencyEnum
  purchased_at: Date | string
  expires_at: Date | string
}

export type SubscriptionPurchaseUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  price_paid?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  currency?: Prisma.EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
  purchased_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expires_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SubscriptionPurchaseUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  user_id?: Prisma.StringFieldUpdateOperationsInput | string
  subscription_plan_id?: Prisma.StringFieldUpdateOperationsInput | string
  price_paid?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  currency?: Prisma.EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
  purchased_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expires_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SubscriptionPurchaseListRelationFilter = {
  every?: Prisma.SubscriptionPurchaseWhereInput
  some?: Prisma.SubscriptionPurchaseWhereInput
  none?: Prisma.SubscriptionPurchaseWhereInput
}

export type SubscriptionPurchaseOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type SubscriptionPurchaseOrderByRelevanceInput = {
  fields: Prisma.SubscriptionPurchaseOrderByRelevanceFieldEnum | Prisma.SubscriptionPurchaseOrderByRelevanceFieldEnum[]
  sort: Prisma.SortOrder
  search: string
}

export type SubscriptionPurchaseCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  user_id?: Prisma.SortOrder
  subscription_plan_id?: Prisma.SortOrder
  price_paid?: Prisma.SortOrder
  currency?: Prisma.SortOrder
  purchased_at?: Prisma.SortOrder
  expires_at?: Prisma.SortOrder
}

export type SubscriptionPurchaseAvgOrderByAggregateInput = {
  price_paid?: Prisma.SortOrder
}

export type SubscriptionPurchaseMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  user_id?: Prisma.SortOrder
  subscription_plan_id?: Prisma.SortOrder
  price_paid?: Prisma.SortOrder
  currency?: Prisma.SortOrder
  purchased_at?: Prisma.SortOrder
  expires_at?: Prisma.SortOrder
}

export type SubscriptionPurchaseMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  user_id?: Prisma.SortOrder
  subscription_plan_id?: Prisma.SortOrder
  price_paid?: Prisma.SortOrder
  currency?: Prisma.SortOrder
  purchased_at?: Prisma.SortOrder
  expires_at?: Prisma.SortOrder
}

export type SubscriptionPurchaseSumOrderByAggregateInput = {
  price_paid?: Prisma.SortOrder
}

export type SubscriptionPurchaseCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.SubscriptionPurchaseCreateWithoutUserInput, Prisma.SubscriptionPurchaseUncheckedCreateWithoutUserInput> | Prisma.SubscriptionPurchaseCreateWithoutUserInput[] | Prisma.SubscriptionPurchaseUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.SubscriptionPurchaseCreateOrConnectWithoutUserInput | Prisma.SubscriptionPurchaseCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.SubscriptionPurchaseCreateManyUserInputEnvelope
  connect?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
}

export type SubscriptionPurchaseUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.SubscriptionPurchaseCreateWithoutUserInput, Prisma.SubscriptionPurchaseUncheckedCreateWithoutUserInput> | Prisma.SubscriptionPurchaseCreateWithoutUserInput[] | Prisma.SubscriptionPurchaseUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.SubscriptionPurchaseCreateOrConnectWithoutUserInput | Prisma.SubscriptionPurchaseCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.SubscriptionPurchaseCreateManyUserInputEnvelope
  connect?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
}

export type SubscriptionPurchaseUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.SubscriptionPurchaseCreateWithoutUserInput, Prisma.SubscriptionPurchaseUncheckedCreateWithoutUserInput> | Prisma.SubscriptionPurchaseCreateWithoutUserInput[] | Prisma.SubscriptionPurchaseUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.SubscriptionPurchaseCreateOrConnectWithoutUserInput | Prisma.SubscriptionPurchaseCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.SubscriptionPurchaseUpsertWithWhereUniqueWithoutUserInput | Prisma.SubscriptionPurchaseUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.SubscriptionPurchaseCreateManyUserInputEnvelope
  set?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
  disconnect?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
  delete?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
  connect?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
  update?: Prisma.SubscriptionPurchaseUpdateWithWhereUniqueWithoutUserInput | Prisma.SubscriptionPurchaseUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.SubscriptionPurchaseUpdateManyWithWhereWithoutUserInput | Prisma.SubscriptionPurchaseUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.SubscriptionPurchaseScalarWhereInput | Prisma.SubscriptionPurchaseScalarWhereInput[]
}

export type SubscriptionPurchaseUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.SubscriptionPurchaseCreateWithoutUserInput, Prisma.SubscriptionPurchaseUncheckedCreateWithoutUserInput> | Prisma.SubscriptionPurchaseCreateWithoutUserInput[] | Prisma.SubscriptionPurchaseUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.SubscriptionPurchaseCreateOrConnectWithoutUserInput | Prisma.SubscriptionPurchaseCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.SubscriptionPurchaseUpsertWithWhereUniqueWithoutUserInput | Prisma.SubscriptionPurchaseUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.SubscriptionPurchaseCreateManyUserInputEnvelope
  set?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
  disconnect?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
  delete?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
  connect?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
  update?: Prisma.SubscriptionPurchaseUpdateWithWhereUniqueWithoutUserInput | Prisma.SubscriptionPurchaseUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.SubscriptionPurchaseUpdateManyWithWhereWithoutUserInput | Prisma.SubscriptionPurchaseUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.SubscriptionPurchaseScalarWhereInput | Prisma.SubscriptionPurchaseScalarWhereInput[]
}

export type SubscriptionPurchaseCreateNestedManyWithoutSubscriptionPlanInput = {
  create?: Prisma.XOR<Prisma.SubscriptionPurchaseCreateWithoutSubscriptionPlanInput, Prisma.SubscriptionPurchaseUncheckedCreateWithoutSubscriptionPlanInput> | Prisma.SubscriptionPurchaseCreateWithoutSubscriptionPlanInput[] | Prisma.SubscriptionPurchaseUncheckedCreateWithoutSubscriptionPlanInput[]
  connectOrCreate?: Prisma.SubscriptionPurchaseCreateOrConnectWithoutSubscriptionPlanInput | Prisma.SubscriptionPurchaseCreateOrConnectWithoutSubscriptionPlanInput[]
  createMany?: Prisma.SubscriptionPurchaseCreateManySubscriptionPlanInputEnvelope
  connect?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
}

export type SubscriptionPurchaseUncheckedCreateNestedManyWithoutSubscriptionPlanInput = {
  create?: Prisma.XOR<Prisma.SubscriptionPurchaseCreateWithoutSubscriptionPlanInput, Prisma.SubscriptionPurchaseUncheckedCreateWithoutSubscriptionPlanInput> | Prisma.SubscriptionPurchaseCreateWithoutSubscriptionPlanInput[] | Prisma.SubscriptionPurchaseUncheckedCreateWithoutSubscriptionPlanInput[]
  connectOrCreate?: Prisma.SubscriptionPurchaseCreateOrConnectWithoutSubscriptionPlanInput | Prisma.SubscriptionPurchaseCreateOrConnectWithoutSubscriptionPlanInput[]
  createMany?: Prisma.SubscriptionPurchaseCreateManySubscriptionPlanInputEnvelope
  connect?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
}

export type SubscriptionPurchaseUpdateManyWithoutSubscriptionPlanNestedInput = {
  create?: Prisma.XOR<Prisma.SubscriptionPurchaseCreateWithoutSubscriptionPlanInput, Prisma.SubscriptionPurchaseUncheckedCreateWithoutSubscriptionPlanInput> | Prisma.SubscriptionPurchaseCreateWithoutSubscriptionPlanInput[] | Prisma.SubscriptionPurchaseUncheckedCreateWithoutSubscriptionPlanInput[]
  connectOrCreate?: Prisma.SubscriptionPurchaseCreateOrConnectWithoutSubscriptionPlanInput | Prisma.SubscriptionPurchaseCreateOrConnectWithoutSubscriptionPlanInput[]
  upsert?: Prisma.SubscriptionPurchaseUpsertWithWhereUniqueWithoutSubscriptionPlanInput | Prisma.SubscriptionPurchaseUpsertWithWhereUniqueWithoutSubscriptionPlanInput[]
  createMany?: Prisma.SubscriptionPurchaseCreateManySubscriptionPlanInputEnvelope
  set?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
  disconnect?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
  delete?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
  connect?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
  update?: Prisma.SubscriptionPurchaseUpdateWithWhereUniqueWithoutSubscriptionPlanInput | Prisma.SubscriptionPurchaseUpdateWithWhereUniqueWithoutSubscriptionPlanInput[]
  updateMany?: Prisma.SubscriptionPurchaseUpdateManyWithWhereWithoutSubscriptionPlanInput | Prisma.SubscriptionPurchaseUpdateManyWithWhereWithoutSubscriptionPlanInput[]
  deleteMany?: Prisma.SubscriptionPurchaseScalarWhereInput | Prisma.SubscriptionPurchaseScalarWhereInput[]
}

export type SubscriptionPurchaseUncheckedUpdateManyWithoutSubscriptionPlanNestedInput = {
  create?: Prisma.XOR<Prisma.SubscriptionPurchaseCreateWithoutSubscriptionPlanInput, Prisma.SubscriptionPurchaseUncheckedCreateWithoutSubscriptionPlanInput> | Prisma.SubscriptionPurchaseCreateWithoutSubscriptionPlanInput[] | Prisma.SubscriptionPurchaseUncheckedCreateWithoutSubscriptionPlanInput[]
  connectOrCreate?: Prisma.SubscriptionPurchaseCreateOrConnectWithoutSubscriptionPlanInput | Prisma.SubscriptionPurchaseCreateOrConnectWithoutSubscriptionPlanInput[]
  upsert?: Prisma.SubscriptionPurchaseUpsertWithWhereUniqueWithoutSubscriptionPlanInput | Prisma.SubscriptionPurchaseUpsertWithWhereUniqueWithoutSubscriptionPlanInput[]
  createMany?: Prisma.SubscriptionPurchaseCreateManySubscriptionPlanInputEnvelope
  set?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
  disconnect?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
  delete?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
  connect?: Prisma.SubscriptionPurchaseWhereUniqueInput | Prisma.SubscriptionPurchaseWhereUniqueInput[]
  update?: Prisma.SubscriptionPurchaseUpdateWithWhereUniqueWithoutSubscriptionPlanInput | Prisma.SubscriptionPurchaseUpdateWithWhereUniqueWithoutSubscriptionPlanInput[]
  updateMany?: Prisma.SubscriptionPurchaseUpdateManyWithWhereWithoutSubscriptionPlanInput | Prisma.SubscriptionPurchaseUpdateManyWithWhereWithoutSubscriptionPlanInput[]
  deleteMany?: Prisma.SubscriptionPurchaseScalarWhereInput | Prisma.SubscriptionPurchaseScalarWhereInput[]
}

export type SubscriptionPurchaseCreateWithoutUserInput = {
  id?: string
  price_paid: runtime.Decimal | runtime.DecimalJsLike | number | string
  currency: $Enums.CurrencyEnum
  purchased_at: Date | string
  expires_at: Date | string
  SubscriptionPlan: Prisma.SubscriptionPlanCreateNestedOneWithoutSubscriptionPurchaseInput
}

export type SubscriptionPurchaseUncheckedCreateWithoutUserInput = {
  id?: string
  subscription_plan_id: string
  price_paid: runtime.Decimal | runtime.DecimalJsLike | number | string
  currency: $Enums.CurrencyEnum
  purchased_at: Date | string
  expires_at: Date | string
}

export type SubscriptionPurchaseCreateOrConnectWithoutUserInput = {
  where: Prisma.SubscriptionPurchaseWhereUniqueInput
  create: Prisma.XOR<Prisma.SubscriptionPurchaseCreateWithoutUserInput, Prisma.SubscriptionPurchaseUncheckedCreateWithoutUserInput>
}

export type SubscriptionPurchaseCreateManyUserInputEnvelope = {
  data: Prisma.SubscriptionPurchaseCreateManyUserInput | Prisma.SubscriptionPurchaseCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type SubscriptionPurchaseUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.SubscriptionPurchaseWhereUniqueInput
  update: Prisma.XOR<Prisma.SubscriptionPurchaseUpdateWithoutUserInput, Prisma.SubscriptionPurchaseUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.SubscriptionPurchaseCreateWithoutUserInput, Prisma.SubscriptionPurchaseUncheckedCreateWithoutUserInput>
}

export type SubscriptionPurchaseUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.SubscriptionPurchaseWhereUniqueInput
  data: Prisma.XOR<Prisma.SubscriptionPurchaseUpdateWithoutUserInput, Prisma.SubscriptionPurchaseUncheckedUpdateWithoutUserInput>
}

export type SubscriptionPurchaseUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.SubscriptionPurchaseScalarWhereInput
  data: Prisma.XOR<Prisma.SubscriptionPurchaseUpdateManyMutationInput, Prisma.SubscriptionPurchaseUncheckedUpdateManyWithoutUserInput>
}

export type SubscriptionPurchaseScalarWhereInput = {
  AND?: Prisma.SubscriptionPurchaseScalarWhereInput | Prisma.SubscriptionPurchaseScalarWhereInput[]
  OR?: Prisma.SubscriptionPurchaseScalarWhereInput[]
  NOT?: Prisma.SubscriptionPurchaseScalarWhereInput | Prisma.SubscriptionPurchaseScalarWhereInput[]
  id?: Prisma.StringFilter<"SubscriptionPurchase"> | string
  user_id?: Prisma.StringFilter<"SubscriptionPurchase"> | string
  subscription_plan_id?: Prisma.StringFilter<"SubscriptionPurchase"> | string
  price_paid?: Prisma.DecimalFilter<"SubscriptionPurchase"> | runtime.Decimal | runtime.DecimalJsLike | number | string
  currency?: Prisma.EnumCurrencyEnumFilter<"SubscriptionPurchase"> | $Enums.CurrencyEnum
  purchased_at?: Prisma.DateTimeFilter<"SubscriptionPurchase"> | Date | string
  expires_at?: Prisma.DateTimeFilter<"SubscriptionPurchase"> | Date | string
}

export type SubscriptionPurchaseCreateWithoutSubscriptionPlanInput = {
  id?: string
  price_paid: runtime.Decimal | runtime.DecimalJsLike | number | string
  currency: $Enums.CurrencyEnum
  purchased_at: Date | string
  expires_at: Date | string
  User: Prisma.UserCreateNestedOneWithoutSubscriptionPurchaseInput
}

export type SubscriptionPurchaseUncheckedCreateWithoutSubscriptionPlanInput = {
  id?: string
  user_id: string
  price_paid: runtime.Decimal | runtime.DecimalJsLike | number | string
  currency: $Enums.CurrencyEnum
  purchased_at: Date | string
  expires_at: Date | string
}

export type SubscriptionPurchaseCreateOrConnectWithoutSubscriptionPlanInput = {
  where: Prisma.SubscriptionPurchaseWhereUniqueInput
  create: Prisma.XOR<Prisma.SubscriptionPurchaseCreateWithoutSubscriptionPlanInput, Prisma.SubscriptionPurchaseUncheckedCreateWithoutSubscriptionPlanInput>
}

export type SubscriptionPurchaseCreateManySubscriptionPlanInputEnvelope = {
  data: Prisma.SubscriptionPurchaseCreateManySubscriptionPlanInput | Prisma.SubscriptionPurchaseCreateManySubscriptionPlanInput[]
  skipDuplicates?: boolean
}

export type SubscriptionPurchaseUpsertWithWhereUniqueWithoutSubscriptionPlanInput = {
  where: Prisma.SubscriptionPurchaseWhereUniqueInput
  update: Prisma.XOR<Prisma.SubscriptionPurchaseUpdateWithoutSubscriptionPlanInput, Prisma.SubscriptionPurchaseUncheckedUpdateWithoutSubscriptionPlanInput>
  create: Prisma.XOR<Prisma.SubscriptionPurchaseCreateWithoutSubscriptionPlanInput, Prisma.SubscriptionPurchaseUncheckedCreateWithoutSubscriptionPlanInput>
}

export type SubscriptionPurchaseUpdateWithWhereUniqueWithoutSubscriptionPlanInput = {
  where: Prisma.SubscriptionPurchaseWhereUniqueInput
  data: Prisma.XOR<Prisma.SubscriptionPurchaseUpdateWithoutSubscriptionPlanInput, Prisma.SubscriptionPurchaseUncheckedUpdateWithoutSubscriptionPlanInput>
}

export type SubscriptionPurchaseUpdateManyWithWhereWithoutSubscriptionPlanInput = {
  where: Prisma.SubscriptionPurchaseScalarWhereInput
  data: Prisma.XOR<Prisma.SubscriptionPurchaseUpdateManyMutationInput, Prisma.SubscriptionPurchaseUncheckedUpdateManyWithoutSubscriptionPlanInput>
}

export type SubscriptionPurchaseCreateManyUserInput = {
  id?: string
  subscription_plan_id: string
  price_paid: runtime.Decimal | runtime.DecimalJsLike | number | string
  currency: $Enums.CurrencyEnum
  purchased_at: Date | string
  expires_at: Date | string
}

export type SubscriptionPurchaseUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  price_paid?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  currency?: Prisma.EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
  purchased_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expires_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  SubscriptionPlan?: Prisma.SubscriptionPlanUpdateOneRequiredWithoutSubscriptionPurchaseNestedInput
}

export type SubscriptionPurchaseUncheckedUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  subscription_plan_id?: Prisma.StringFieldUpdateOperationsInput | string
  price_paid?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  currency?: Prisma.EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
  purchased_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expires_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SubscriptionPurchaseUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  subscription_plan_id?: Prisma.StringFieldUpdateOperationsInput | string
  price_paid?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  currency?: Prisma.EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
  purchased_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expires_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SubscriptionPurchaseCreateManySubscriptionPlanInput = {
  id?: string
  user_id: string
  price_paid: runtime.Decimal | runtime.DecimalJsLike | number | string
  currency: $Enums.CurrencyEnum
  purchased_at: Date | string
  expires_at: Date | string
}

export type SubscriptionPurchaseUpdateWithoutSubscriptionPlanInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  price_paid?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  currency?: Prisma.EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
  purchased_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expires_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  User?: Prisma.UserUpdateOneRequiredWithoutSubscriptionPurchaseNestedInput
}

export type SubscriptionPurchaseUncheckedUpdateWithoutSubscriptionPlanInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  user_id?: Prisma.StringFieldUpdateOperationsInput | string
  price_paid?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  currency?: Prisma.EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
  purchased_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expires_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SubscriptionPurchaseUncheckedUpdateManyWithoutSubscriptionPlanInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  user_id?: Prisma.StringFieldUpdateOperationsInput | string
  price_paid?: Prisma.DecimalFieldUpdateOperationsInput | runtime.Decimal | runtime.DecimalJsLike | number | string
  currency?: Prisma.EnumCurrencyEnumFieldUpdateOperationsInput | $Enums.CurrencyEnum
  purchased_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  expires_at?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type SubscriptionPurchaseSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  user_id?: boolean
  subscription_plan_id?: boolean
  price_paid?: boolean
  currency?: boolean
  purchased_at?: boolean
  expires_at?: boolean
  SubscriptionPlan?: boolean | Prisma.SubscriptionPlanDefaultArgs<ExtArgs>
  User?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["subscriptionPurchase"]>



export type SubscriptionPurchaseSelectScalar = {
  id?: boolean
  user_id?: boolean
  subscription_plan_id?: boolean
  price_paid?: boolean
  currency?: boolean
  purchased_at?: boolean
  expires_at?: boolean
}

export type SubscriptionPurchaseOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "user_id" | "subscription_plan_id" | "price_paid" | "currency" | "purchased_at" | "expires_at", ExtArgs["result"]["subscriptionPurchase"]>
export type SubscriptionPurchaseInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  SubscriptionPlan?: boolean | Prisma.SubscriptionPlanDefaultArgs<ExtArgs>
  User?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}

export type $SubscriptionPurchasePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "SubscriptionPurchase"
  objects: {
    SubscriptionPlan: Prisma.$SubscriptionPlanPayload<ExtArgs>
    User: Prisma.$UserPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    user_id: string
    subscription_plan_id: string
    price_paid: runtime.Decimal
    currency: $Enums.CurrencyEnum
    purchased_at: Date
    expires_at: Date
  }, ExtArgs["result"]["subscriptionPurchase"]>
  composites: {}
}

export type SubscriptionPurchaseGetPayload<S extends boolean | null | undefined | SubscriptionPurchaseDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$SubscriptionPurchasePayload, S>

export type SubscriptionPurchaseCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<SubscriptionPurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: SubscriptionPurchaseCountAggregateInputType | true
  }

export interface SubscriptionPurchaseDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPurchase'], meta: { name: 'SubscriptionPurchase' } }
  /**
   * Find zero or one SubscriptionPurchase that matches the filter.
   * @param {SubscriptionPurchaseFindUniqueArgs} args - Arguments to find a SubscriptionPurchase
   * @example
   * // Get one SubscriptionPurchase
   * const subscriptionPurchase = await prisma.subscriptionPurchase.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends SubscriptionPurchaseFindUniqueArgs>(args: Prisma.SelectSubset<T, SubscriptionPurchaseFindUniqueArgs<ExtArgs>>): Prisma.Prisma__SubscriptionPurchaseClient<runtime.Types.Result.GetResult<Prisma.$SubscriptionPurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one SubscriptionPurchase that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {SubscriptionPurchaseFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPurchase
   * @example
   * // Get one SubscriptionPurchase
   * const subscriptionPurchase = await prisma.subscriptionPurchase.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends SubscriptionPurchaseFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, SubscriptionPurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__SubscriptionPurchaseClient<runtime.Types.Result.GetResult<Prisma.$SubscriptionPurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first SubscriptionPurchase that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SubscriptionPurchaseFindFirstArgs} args - Arguments to find a SubscriptionPurchase
   * @example
   * // Get one SubscriptionPurchase
   * const subscriptionPurchase = await prisma.subscriptionPurchase.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends SubscriptionPurchaseFindFirstArgs>(args?: Prisma.SelectSubset<T, SubscriptionPurchaseFindFirstArgs<ExtArgs>>): Prisma.Prisma__SubscriptionPurchaseClient<runtime.Types.Result.GetResult<Prisma.$SubscriptionPurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first SubscriptionPurchase that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SubscriptionPurchaseFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPurchase
   * @example
   * // Get one SubscriptionPurchase
   * const subscriptionPurchase = await prisma.subscriptionPurchase.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends SubscriptionPurchaseFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, SubscriptionPurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__SubscriptionPurchaseClient<runtime.Types.Result.GetResult<Prisma.$SubscriptionPurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more SubscriptionPurchases that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SubscriptionPurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all SubscriptionPurchases
   * const subscriptionPurchases = await prisma.subscriptionPurchase.findMany()
   * 
   * // Get first 10 SubscriptionPurchases
   * const subscriptionPurchases = await prisma.subscriptionPurchase.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const subscriptionPurchaseWithIdOnly = await prisma.subscriptionPurchase.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends SubscriptionPurchaseFindManyArgs>(args?: Prisma.SelectSubset<T, SubscriptionPurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$SubscriptionPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a SubscriptionPurchase.
   * @param {SubscriptionPurchaseCreateArgs} args - Arguments to create a SubscriptionPurchase.
   * @example
   * // Create one SubscriptionPurchase
   * const SubscriptionPurchase = await prisma.subscriptionPurchase.create({
   *   data: {
   *     // ... data to create a SubscriptionPurchase
   *   }
   * })
   * 
   */
  create<T extends SubscriptionPurchaseCreateArgs>(args: Prisma.SelectSubset<T, SubscriptionPurchaseCreateArgs<ExtArgs>>): Prisma.Prisma__SubscriptionPurchaseClient<runtime.Types.Result.GetResult<Prisma.$SubscriptionPurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many SubscriptionPurchases.
   * @param {SubscriptionPurchaseCreateManyArgs} args - Arguments to create many SubscriptionPurchases.
   * @example
   * // Create many SubscriptionPurchases
   * const subscriptionPurchase = await prisma.subscriptionPurchase.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends SubscriptionPurchaseCreateManyArgs>(args?: Prisma.SelectSubset<T, SubscriptionPurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Delete a SubscriptionPurchase.
   * @param {SubscriptionPurchaseDeleteArgs} args - Arguments to delete one SubscriptionPurchase.
   * @example
   * // Delete one SubscriptionPurchase
   * const SubscriptionPurchase = await prisma.subscriptionPurchase.delete({
   *   where: {
   *     // ... filter to delete one SubscriptionPurchase
   *   }
   * })
   * 
   */
  delete<T extends SubscriptionPurchaseDeleteArgs>(args: Prisma.SelectSubset<T, SubscriptionPurchaseDeleteArgs<ExtArgs>>): Prisma.Prisma__SubscriptionPurchaseClient<runtime.Types.Result.GetResult<Prisma.$SubscriptionPurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one SubscriptionPurchase.
   * @param {SubscriptionPurchaseUpdateArgs} args - Arguments to update one SubscriptionPurchase.
   * @example
   * // Update one SubscriptionPurchase
   * const subscriptionPurchase = await prisma.subscriptionPurchase.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends SubscriptionPurchaseUpdateArgs>(args: Prisma.SelectSubset<T, SubscriptionPurchaseUpdateArgs<ExtArgs>>): Prisma.Prisma__SubscriptionPurchaseClient<runtime.Types.Result.GetResult<Prisma.$SubscriptionPurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more SubscriptionPurchases.
   * @param {SubscriptionPurchaseDeleteManyArgs} args - Arguments to filter SubscriptionPurchases to delete.
   * @example
   * // Delete a few SubscriptionPurchases
   * const { count } = await prisma.subscriptionPurchase.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends SubscriptionPurchaseDeleteManyArgs>(args?: Prisma.SelectSubset<T, SubscriptionPurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more SubscriptionPurchases.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SubscriptionPurchaseUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many SubscriptionPurchases
   * const subscriptionPurchase = await prisma.subscriptionPurchase.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends SubscriptionPurchaseUpdateManyArgs>(args: Prisma.SelectSubset<T, SubscriptionPurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create or update one SubscriptionPurchase.
   * @param {SubscriptionPurchaseUpsertArgs} args - Arguments to update or create a SubscriptionPurchase.
   * @example
   * // Update or create a SubscriptionPurchase
   * const subscriptionPurchase = await prisma.subscriptionPurchase.upsert({
   *   create: {
   *     // ... data to create a SubscriptionPurchase
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the SubscriptionPurchase we want to update
   *   }
   * })
   */
  upsert<T extends SubscriptionPurchaseUpsertArgs>(args: Prisma.SelectSubset<T, SubscriptionPurchaseUpsertArgs<ExtArgs>>): Prisma.Prisma__SubscriptionPurchaseClient<runtime.Types.Result.GetResult<Prisma.$SubscriptionPurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of SubscriptionPurchases.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SubscriptionPurchaseCountArgs} args - Arguments to filter SubscriptionPurchases to count.
   * @example
   * // Count the number of SubscriptionPurchases
   * const count = await prisma.subscriptionPurchase.count({
   *   where: {
   *     // ... the filter for the SubscriptionPurchases we want to count
   *   }
   * })
  **/
  count<T extends SubscriptionPurchaseCountArgs>(
    args?: Prisma.Subset<T, SubscriptionPurchaseCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], SubscriptionPurchaseCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a SubscriptionPurchase.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SubscriptionPurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends SubscriptionPurchaseAggregateArgs>(args: Prisma.Subset<T, SubscriptionPurchaseAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionPurchaseAggregateType<T>>

  /**
   * Group by SubscriptionPurchase.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SubscriptionPurchaseGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends SubscriptionPurchaseGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: SubscriptionPurchaseGroupByArgs['orderBy'] }
      : { orderBy?: SubscriptionPurchaseGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, SubscriptionPurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the SubscriptionPurchase model
 */
readonly fields: SubscriptionPurchaseFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for SubscriptionPurchase.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__SubscriptionPurchaseClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  SubscriptionPlan<T extends Prisma.SubscriptionPlanDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.SubscriptionPlanDefaultArgs<ExtArgs>>): Prisma.Prisma__SubscriptionPlanClient<runtime.Types.Result.GetResult<Prisma.$SubscriptionPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  User<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the SubscriptionPurchase model
 */
export interface SubscriptionPurchaseFieldRefs {
  readonly id: Prisma.FieldRef<"SubscriptionPurchase", 'String'>
  readonly user_id: Prisma.FieldRef<"SubscriptionPurchase", 'String'>
  readonly subscription_plan_id: Prisma.FieldRef<"SubscriptionPurchase", 'String'>
  readonly price_paid: Prisma.FieldRef<"SubscriptionPurchase", 'Decimal'>
  readonly currency: Prisma.FieldRef<"SubscriptionPurchase", 'CurrencyEnum'>
  readonly purchased_at: Prisma.FieldRef<"SubscriptionPurchase", 'DateTime'>
  readonly expires_at: Prisma.FieldRef<"SubscriptionPurchase", 'DateTime'>
}
    

// Custom InputTypes
/**
 * SubscriptionPurchase findUnique
 */
export type SubscriptionPurchaseFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SubscriptionPurchase
   */
  select?: Prisma.SubscriptionPurchaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SubscriptionPurchase
   */
  omit?: Prisma.SubscriptionPurchaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionPurchaseInclude<ExtArgs> | null
  /**
   * Filter, which SubscriptionPurchase to fetch.
   */
  where: Prisma.SubscriptionPurchaseWhereUniqueInput
}

/**
 * SubscriptionPurchase findUniqueOrThrow
 */
export type SubscriptionPurchaseFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SubscriptionPurchase
   */
  select?: Prisma.SubscriptionPurchaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SubscriptionPurchase
   */
  omit?: Prisma.SubscriptionPurchaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionPurchaseInclude<ExtArgs> | null
  /**
   * Filter, which SubscriptionPurchase to fetch.
   */
  where: Prisma.SubscriptionPurchaseWhereUniqueInput
}

/**
 * SubscriptionPurchase findFirst
 */
export type SubscriptionPurchaseFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SubscriptionPurchase
   */
  select?: Prisma.SubscriptionPurchaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SubscriptionPurchase
   */
  omit?: Prisma.SubscriptionPurchaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionPurchaseInclude<ExtArgs> | null
  /**
   * Filter, which SubscriptionPurchase to fetch.
   */
  where?: Prisma.SubscriptionPurchaseWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of SubscriptionPurchases to fetch.
   */
  orderBy?: Prisma.SubscriptionPurchaseOrderByWithRelationInput | Prisma.SubscriptionPurchaseOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for SubscriptionPurchases.
   */
  cursor?: Prisma.SubscriptionPurchaseWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` SubscriptionPurchases from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` SubscriptionPurchases.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of SubscriptionPurchases.
   */
  distinct?: Prisma.SubscriptionPurchaseScalarFieldEnum | Prisma.SubscriptionPurchaseScalarFieldEnum[]
}

/**
 * SubscriptionPurchase findFirstOrThrow
 */
export type SubscriptionPurchaseFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SubscriptionPurchase
   */
  select?: Prisma.SubscriptionPurchaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SubscriptionPurchase
   */
  omit?: Prisma.SubscriptionPurchaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionPurchaseInclude<ExtArgs> | null
  /**
   * Filter, which SubscriptionPurchase to fetch.
   */
  where?: Prisma.SubscriptionPurchaseWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of SubscriptionPurchases to fetch.
   */
  orderBy?: Prisma.SubscriptionPurchaseOrderByWithRelationInput | Prisma.SubscriptionPurchaseOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for SubscriptionPurchases.
   */
  cursor?: Prisma.SubscriptionPurchaseWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` SubscriptionPurchases from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` SubscriptionPurchases.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of SubscriptionPurchases.
   */
  distinct?: Prisma.SubscriptionPurchaseScalarFieldEnum | Prisma.SubscriptionPurchaseScalarFieldEnum[]
}

/**
 * SubscriptionPurchase findMany
 */
export type SubscriptionPurchaseFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SubscriptionPurchase
   */
  select?: Prisma.SubscriptionPurchaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SubscriptionPurchase
   */
  omit?: Prisma.SubscriptionPurchaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionPurchaseInclude<ExtArgs> | null
  /**
   * Filter, which SubscriptionPurchases to fetch.
   */
  where?: Prisma.SubscriptionPurchaseWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of SubscriptionPurchases to fetch.
   */
  orderBy?: Prisma.SubscriptionPurchaseOrderByWithRelationInput | Prisma.SubscriptionPurchaseOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing SubscriptionPurchases.
   */
  cursor?: Prisma.SubscriptionPurchaseWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` SubscriptionPurchases from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` SubscriptionPurchases.
   */
  skip?: number
  distinct?: Prisma.SubscriptionPurchaseScalarFieldEnum | Prisma.SubscriptionPurchaseScalarFieldEnum[]
}

/**
 * SubscriptionPurchase create
 */
export type SubscriptionPurchaseCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SubscriptionPurchase
   */
  select?: Prisma.SubscriptionPurchaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SubscriptionPurchase
   */
  omit?: Prisma.SubscriptionPurchaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionPurchaseInclude<ExtArgs> | null
  /**
   * The data needed to create a SubscriptionPurchase.
   */
  data: Prisma.XOR<Prisma.SubscriptionPurchaseCreateInput, Prisma.SubscriptionPurchaseUncheckedCreateInput>
}

/**
 * SubscriptionPurchase createMany
 */
export type SubscriptionPurchaseCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many SubscriptionPurchases.
   */
  data: Prisma.SubscriptionPurchaseCreateManyInput | Prisma.SubscriptionPurchaseCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * SubscriptionPurchase update
 */
export type SubscriptionPurchaseUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SubscriptionPurchase
   */
  select?: Prisma.SubscriptionPurchaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SubscriptionPurchase
   */
  omit?: Prisma.SubscriptionPurchaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionPurchaseInclude<ExtArgs> | null
  /**
   * The data needed to update a SubscriptionPurchase.
   */
  data: Prisma.XOR<Prisma.SubscriptionPurchaseUpdateInput, Prisma.SubscriptionPurchaseUncheckedUpdateInput>
  /**
   * Choose, which SubscriptionPurchase to update.
   */
  where: Prisma.SubscriptionPurchaseWhereUniqueInput
}

/**
 * SubscriptionPurchase updateMany
 */
export type SubscriptionPurchaseUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update SubscriptionPurchases.
   */
  data: Prisma.XOR<Prisma.SubscriptionPurchaseUpdateManyMutationInput, Prisma.SubscriptionPurchaseUncheckedUpdateManyInput>
  /**
   * Filter which SubscriptionPurchases to update
   */
  where?: Prisma.SubscriptionPurchaseWhereInput
  /**
   * Limit how many SubscriptionPurchases to update.
   */
  limit?: number
}

/**
 * SubscriptionPurchase upsert
 */
export type SubscriptionPurchaseUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SubscriptionPurchase
   */
  select?: Prisma.SubscriptionPurchaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SubscriptionPurchase
   */
  omit?: Prisma.SubscriptionPurchaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionPurchaseInclude<ExtArgs> | null
  /**
   * The filter to search for the SubscriptionPurchase to update in case it exists.
   */
  where: Prisma.SubscriptionPurchaseWhereUniqueInput
  /**
   * In case the SubscriptionPurchase found by the `where` argument doesn't exist, create a new SubscriptionPurchase with this data.
   */
  create: Prisma.XOR<Prisma.SubscriptionPurchaseCreateInput, Prisma.SubscriptionPurchaseUncheckedCreateInput>
  /**
   * In case the SubscriptionPurchase was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.SubscriptionPurchaseUpdateInput, Prisma.SubscriptionPurchaseUncheckedUpdateInput>
}

/**
 * SubscriptionPurchase delete
 */
export type SubscriptionPurchaseDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SubscriptionPurchase
   */
  select?: Prisma.SubscriptionPurchaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SubscriptionPurchase
   */
  omit?: Prisma.SubscriptionPurchaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionPurchaseInclude<ExtArgs> | null
  /**
   * Filter which SubscriptionPurchase to delete.
   */
  where: Prisma.SubscriptionPurchaseWhereUniqueInput
}

/**
 * SubscriptionPurchase deleteMany
 */
export type SubscriptionPurchaseDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which SubscriptionPurchases to delete
   */
  where?: Prisma.SubscriptionPurchaseWhereInput
  /**
   * Limit how many SubscriptionPurchases to delete.
   */
  limit?: number
}

/**
 * SubscriptionPurchase without action
 */
export type SubscriptionPurchaseDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SubscriptionPurchase
   */
  select?: Prisma.SubscriptionPurchaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SubscriptionPurchase
   */
  omit?: Prisma.SubscriptionPurchaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SubscriptionPurchaseInclude<ExtArgs> | null
}
